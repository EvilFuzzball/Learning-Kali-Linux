-	The %n format outputs the total amount of bytes written before it.
-	When exploiting a format string, you need to be placing format parameters in the
	input format statement. Example: printf("This is my string %s", string);
	
	This is fine, but check this out
	printf("%s");
	
	Because there are no parameters, this will print out whatever is stored in the
	next memory address on the stack. Because of this, one can use format string
	exploits to view the memory on the stack to create further exploitations.

-	COOL TRICK: You can figure out the memory address of an environment variable
				and use input it as little endian hexadecimal to get its value!
				Example: ./program $(printf "\xd7\xfd\xff\xbf")%08x.%08x.%08x.%s

				
-	WRITING TO VARIABLE VIA FORMAT STRINGS
-	IMPORTANT!!
	Make sure to figure out how many JUNK bytes you will need and you need to know
	the exact memory locations you will be writing to before you do anything!!
	
	
-	We need to use the %n format parameter to do this.
-	The value of the affected variable will change depending on the input field width

-	String format exploits can be used to view environment variables, but does
	not seem to work for local variables. Note that you must define the memory address
	at which the environment variable is at because it changes with respect to the
	program's name that is running it.

-	We can view the memory by spamming %08x to view all the memory addresses and
	eventually we will bump into the memory address we wish to write to.
-	We can write to this memory address by subsituting the %08x with %n
-	Note that when you substitute the format parameter, you are writing a byte to that 
	memory address with %n.
-	Since you will be writing with %n, that value will be popped off the stack
	and we will want to write to the next byte. Therefore, we must add a 4 byte filler
	to the string so that we can make more adjustments to the width of the input holder.
	We use the format width so that we can get an exact hexadecimal value to write to the
	memory address.

-	NOTE: Sometimes the difference will be less than 8 bytes (the default size of 
	a memory address) so you will have to wrap around. Example: 0xbb - 0xb4 = 7
	THis will not be enough to fill a byte. Therefore, do this: 0x1bb - 0xb4 = 263

-	The special gdb command for this is:
	gdb -q --batch -ex "p 0x1bb - 0xb4"
	
-	Keep doing this until the target memory address has been overwriten.


- 	Try corrupting a memory address with this value: 0x0806abcd

-	Overall, when calculating the next byte to corrupt, just use common sense math.
	

